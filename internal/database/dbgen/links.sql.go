// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: links.sql

package dbgen

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const links_CountAll = `-- name: Links_CountAll :one
SELECT COUNT(*) FROM links
`

func (q *Queries) Links_CountAll(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, links_CountAll)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const links_Create = `-- name: Links_Create :one
INSERT INTO links (
    short_code,
    original_url,
    http_redirect_code,
    is_active,
    description,
    tags,
    password,
    expires_at,
    created_by_ip,
    created_by_user_agent
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
) RETURNING id, short_code, original_url, http_redirect_code, is_active, description, tags, password, expires_at, created_by_ip, created_by_user_agent, created_at, updated_at
`

type Links_CreateParams struct {
	ShortCode          string
	OriginalUrl        string
	HttpRedirectCode   int32
	IsActive           bool
	Description        sql.NullString
	Tags               []string
	Password           sql.NullString
	ExpiresAt          sql.NullTime
	CreatedByIp        sql.NullString
	CreatedByUserAgent sql.NullString
}

func (q *Queries) Links_Create(ctx context.Context, arg Links_CreateParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, links_Create,
		arg.ShortCode,
		arg.OriginalUrl,
		arg.HttpRedirectCode,
		arg.IsActive,
		arg.Description,
		pq.Array(arg.Tags),
		arg.Password,
		arg.ExpiresAt,
		arg.CreatedByIp,
		arg.CreatedByUserAgent,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.HttpRedirectCode,
		&i.IsActive,
		&i.Description,
		pq.Array(&i.Tags),
		&i.Password,
		&i.ExpiresAt,
		&i.CreatedByIp,
		&i.CreatedByUserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const links_Delete = `-- name: Links_Delete :exec
DELETE FROM links WHERE id = $1
`

func (q *Queries) Links_Delete(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, links_Delete, id)
	return err
}

const links_Exists = `-- name: Links_Exists :one
SELECT EXISTS (
  SELECT 1
  FROM links
  WHERE id = $1
) AS exists
`

func (q *Queries) Links_Exists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, links_Exists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const links_ExistsByOriginalURL = `-- name: Links_ExistsByOriginalURL :one
SELECT EXISTS (
  SELECT 1
  FROM links
  WHERE original_url = $1
) AS exists
`

func (q *Queries) Links_ExistsByOriginalURL(ctx context.Context, originalUrl string) (bool, error) {
	row := q.db.QueryRowContext(ctx, links_ExistsByOriginalURL, originalUrl)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const links_ExistsByShortCode = `-- name: Links_ExistsByShortCode :one
SELECT EXISTS (
  SELECT 1
  FROM links
  WHERE short_code = $1
) AS exists
`

func (q *Queries) Links_ExistsByShortCode(ctx context.Context, shortCode string) (bool, error) {
	row := q.db.QueryRowContext(ctx, links_ExistsByShortCode, shortCode)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const links_Get = `-- name: Links_Get :one
SELECT id, short_code, original_url, http_redirect_code, is_active, description, tags, password, expires_at, created_by_ip, created_by_user_agent, created_at, updated_at FROM links WHERE id = $1
`

func (q *Queries) Links_Get(ctx context.Context, id uuid.UUID) (Link, error) {
	row := q.db.QueryRowContext(ctx, links_Get, id)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.HttpRedirectCode,
		&i.IsActive,
		&i.Description,
		pq.Array(&i.Tags),
		&i.Password,
		&i.ExpiresAt,
		&i.CreatedByIp,
		&i.CreatedByUserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const links_GetByOriginalURL = `-- name: Links_GetByOriginalURL :one
SELECT id, short_code, original_url, http_redirect_code, is_active, description, tags, password, expires_at, created_by_ip, created_by_user_agent, created_at, updated_at FROM links WHERE original_url = $1
`

func (q *Queries) Links_GetByOriginalURL(ctx context.Context, originalUrl string) (Link, error) {
	row := q.db.QueryRowContext(ctx, links_GetByOriginalURL, originalUrl)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.HttpRedirectCode,
		&i.IsActive,
		&i.Description,
		pq.Array(&i.Tags),
		&i.Password,
		&i.ExpiresAt,
		&i.CreatedByIp,
		&i.CreatedByUserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const links_GetByShortCode = `-- name: Links_GetByShortCode :one
SELECT id, short_code, original_url, http_redirect_code, is_active, description, tags, password, expires_at, created_by_ip, created_by_user_agent, created_at, updated_at FROM links WHERE short_code = $1
`

func (q *Queries) Links_GetByShortCode(ctx context.Context, shortCode string) (Link, error) {
	row := q.db.QueryRowContext(ctx, links_GetByShortCode, shortCode)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.HttpRedirectCode,
		&i.IsActive,
		&i.Description,
		pq.Array(&i.Tags),
		&i.Password,
		&i.ExpiresAt,
		&i.CreatedByIp,
		&i.CreatedByUserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const links_Paginate = `-- name: Links_Paginate :many
SELECT id, short_code, original_url, http_redirect_code, is_active, description, tags, password, expires_at, created_by_ip, created_by_user_agent, created_at, updated_at FROM links
WHERE (
  $3::BOOLEAN IS NULL
  OR
  is_active = $3::BOOLEAN
)
AND (
  $4::TEXT IS NULL
  OR
  original_url ILIKE $4::TEXT
)
AND (
  $5::TEXT IS NULL
  OR
  short_code ILIKE $5::TEXT
)
AND (
  $6::TEXT IS NULL
  OR
  description ILIKE $6::TEXT
)
AND (
  ARRAY_LENGTH($7::TEXT[], 1) = 0
  OR
  tags && $7::TEXT[]
)
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type Links_PaginateParams struct {
	Limit             int32
	Offset            int32
	FilterIsActive    sql.NullBool
	FilterOriginalUrl sql.NullString
	FilterShortCode   sql.NullString
	FilterDescription sql.NullString
	FilterTags        []string
}

func (q *Queries) Links_Paginate(ctx context.Context, arg Links_PaginateParams) ([]Link, error) {
	rows, err := q.db.QueryContext(ctx, links_Paginate,
		arg.Limit,
		arg.Offset,
		arg.FilterIsActive,
		arg.FilterOriginalUrl,
		arg.FilterShortCode,
		arg.FilterDescription,
		pq.Array(arg.FilterTags),
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Link
	for rows.Next() {
		var i Link
		if err := rows.Scan(
			&i.ID,
			&i.ShortCode,
			&i.OriginalUrl,
			&i.HttpRedirectCode,
			&i.IsActive,
			&i.Description,
			pq.Array(&i.Tags),
			&i.Password,
			&i.ExpiresAt,
			&i.CreatedByIp,
			&i.CreatedByUserAgent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const links_PaginateCountTotalMatches = `-- name: Links_PaginateCountTotalMatches :one
SELECT COUNT(*) FROM links
WHERE (
  $1::BOOLEAN IS NULL
  OR
  is_active = $1::BOOLEAN
)
AND (
  $2::TEXT IS NULL
  OR
  original_url ILIKE $2::TEXT
)
AND (
  $3::TEXT IS NULL
  OR
  short_code ILIKE $3::TEXT
)
AND (
  $4::TEXT IS NULL
  OR
  description ILIKE $4::TEXT
)
AND (
  ARRAY_LENGTH($5::TEXT[], 1) = 0
  OR
  tags && $5::TEXT[]
)
`

type Links_PaginateCountTotalMatchesParams struct {
	FilterIsActive    sql.NullBool
	FilterOriginalUrl sql.NullString
	FilterShortCode   sql.NullString
	FilterDescription sql.NullString
	FilterTags        []string
}

func (q *Queries) Links_PaginateCountTotalMatches(ctx context.Context, arg Links_PaginateCountTotalMatchesParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, links_PaginateCountTotalMatches,
		arg.FilterIsActive,
		arg.FilterOriginalUrl,
		arg.FilterShortCode,
		arg.FilterDescription,
		pq.Array(arg.FilterTags),
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const links_Update = `-- name: Links_Update :one
UPDATE links SET
  short_code = COALESCE($2, short_code),
  original_url = COALESCE($3, original_url),
  http_redirect_code = COALESCE($4, http_redirect_code),
  is_active = COALESCE($5, is_active),
  description = COALESCE($6, description),
  tags = COALESCE($7, tags),
  password = COALESCE($8, password),
  expires_at = COALESCE($9, expires_at),
  updated_at = NOW()
WHERE id = $1 RETURNING id, short_code, original_url, http_redirect_code, is_active, description, tags, password, expires_at, created_by_ip, created_by_user_agent, created_at, updated_at
`

type Links_UpdateParams struct {
	ID               uuid.UUID
	ShortCode        string
	OriginalUrl      string
	HttpRedirectCode int32
	IsActive         bool
	Description      sql.NullString
	Tags             []string
	Password         sql.NullString
	ExpiresAt        sql.NullTime
}

func (q *Queries) Links_Update(ctx context.Context, arg Links_UpdateParams) (Link, error) {
	row := q.db.QueryRowContext(ctx, links_Update,
		arg.ID,
		arg.ShortCode,
		arg.OriginalUrl,
		arg.HttpRedirectCode,
		arg.IsActive,
		arg.Description,
		pq.Array(arg.Tags),
		arg.Password,
		arg.ExpiresAt,
	)
	var i Link
	err := row.Scan(
		&i.ID,
		&i.ShortCode,
		&i.OriginalUrl,
		&i.HttpRedirectCode,
		&i.IsActive,
		&i.Description,
		pq.Array(&i.Tags),
		&i.Password,
		&i.ExpiresAt,
		&i.CreatedByIp,
		&i.CreatedByUserAgent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
